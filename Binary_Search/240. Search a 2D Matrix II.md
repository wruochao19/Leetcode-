## 240. Search a 2D Matrix II
Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

**Example 1**
```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```
## 思路
**对于此题，最重要的条件是 ```nums[-1] = nums[n] = -∞```**， 基于这个条件说明题中所给的数字中必然存在一个**峰值点**且：
- 对于任意的 ```nums[i] > nums[i+1]```， 一定有一个峰值点在 i 处或者在 i 的左侧
- 对于任意的 ```nums[i] < nums[i+1]```， 一定有一个峰值点在 i+1 处或者在 i 的右侧

那么对于任意的一个 i 若是```nums[i] > nums[i+1]```我们更新右边界，将搜索范围收敛到左边。反之则跟新左边界，将范围收敛到右边。

则最后得到的```nums[i]```一定满足```num[i-1] < nums[i] < nums[i+1]```

**此方法成立的最重要前置条件为 ```nums[-1] = nums[n] = -∞```**

## 代码
```java
public class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l < r){
            int mid = l + (r-l) / 2;
            if (nums[mid] > nums[mid+1]){
                r = mid;
            }
            else{
                l = mid + 1;
            }
        }
        return l;
    }
}
```
